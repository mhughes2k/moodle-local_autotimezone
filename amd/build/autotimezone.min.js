define("local_autotimezone/autotimezone",["exports","core/log","./repository","./modal_update_ignore","core/pending","core/str","./common"],(function(_exports,_log,_repository,_modal_update_ignore,_pending,_str,_common){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.updateIgnore=_exports.init=void 0,_log=_interopRequireDefault(_log),_modal_update_ignore=_interopRequireDefault(_modal_update_ignore),_pending=_interopRequireDefault(_pending);var _systemImportTransformerGlobalIdentifier="undefined"!=typeof window?window:"undefined"!=typeof self?self:"undefined"!=typeof global?global:{};function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var STRING=null,CONFIG=null;_exports.init=async(currentTimeZone,delay)=>{(CONFIG=_common.DEFAULT_CONFIG).delay=delay,_log.default.info("Loading autotimezone"),_log.default.debug(CONFIG);const stringValues=await(0,_str.getStrings)(_common.STRINGS.map((key=>({key:key,component:"local_autotimezone"}))));if(STRING=new Map(_common.STRINGS.map(((key,index)=>[key,stringValues[index]]))),_log.default.debug(STRING),_log.default.info(currentTimeZone),!navigator.geolocation)return void _log.default.warn("No geolocation API available");_log.default.info("Geolocation API available");let watchid=navigator.geolocation.watchPosition((pos=>{_log.default.info("Got position: "+pos.coords.latitude+", "+pos.coords.longitude),(0,_repository.checkTimezone)(pos.coords.latitude,pos.coords.longitude).then((data=>{_log.default.info(data),"match"!=data.status&&(_log.default.warn("No match"),_log.default.info("Current time zone: "+data.profiletimezone),_log.default.warn("New time zone "+data.timezone),updateIgnore(data.profiletimezone,data.timezone,(()=>{_log.default.info("Updating time zone to "+data.timezone),(0,_repository.updateTimeZone)(data.timezone).then((()=>{window.location.reload()}))}),(()=>{const delayms=1e3*CONFIG.delay,now=new Date,nextCheck=new Date;nextCheck.setTime(now.getTime()+delayms),_log.default.info("Stopping location changes for "+CONFIG.delay+" hrs "+nextCheck.toISOString()),(0,_repository.deferChecks)(nextCheck.getTime()/1e3)}))),navigator.geolocation.clearWatch(watchid)})).fail((error=>{_log.default.error(error),navigator.geolocation.clearWatch(watchid)}))}),(error=>{_log.default.error(error),2==error.code&&_log.default.error("Unable to establish position"),navigator.geolocation.clearWatch(watchid)}))};const updateIgnore=async(profileTz,currentTz,updateCallback,cancelCallback)=>{var pendingPromise=new _pending.default("local/autotimezone:updateIgnore");const[ModalEvents]=await Promise.all(["function"==typeof _systemImportTransformerGlobalIdentifier.define&&_systemImportTransformerGlobalIdentifier.define.amd?new Promise((function(resolve,reject){_systemImportTransformerGlobalIdentifier.require(["core/modal_events"],resolve,reject)})):"undefined"!=typeof module&&module.exports&&"undefined"!=typeof require||"undefined"!=typeof module&&module.component&&_systemImportTransformerGlobalIdentifier.require&&"component"===_systemImportTransformerGlobalIdentifier.require.loader?Promise.resolve(require("core/modal_events")):Promise.resolve(_systemImportTransformerGlobalIdentifier["core/modal_events"])]),title=STRING.get("updatemodaltitle"),body=await(0,_str.getString)("updatemodalbody","local_autotimezone",{profileTz:profileTz,currentTz:currentTz}),updateto=await(0,_str.getString)("updatetimezoneto","local_autotimezone",{currentTz:currentTz}),ignoreforXhrs=await(0,_str.getString)("ignoreforXhrs","local_autotimezone",{delay:CONFIG.delay/3600}),modal=await _modal_update_ignore.default.create({title:title,body:body,buttons:{save:updateto,cancel:ignoreforXhrs},removeOnClose:!0,show:!0});return modal.getRoot().on(ModalEvents.save,updateCallback),modal.getRoot().on(ModalEvents.cancel,cancelCallback),pendingPromise.resolve(),modal};_exports.updateIgnore=updateIgnore}));

//# sourceMappingURL=autotimezone.min.js.map