{"version":3,"file":"autotimezone.min.js","sources":["../src/autotimezone.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport Log from 'core/log';\nimport {checkTimezone, deferChecks, updateTimeZone} from './repository';\n//import { saveCancel } from 'core/notification';\nimport UpdateIgnoreModal from './modal_update_ignore';\nimport Pending from 'core/pending';\nimport {getString, getStrings} from 'core/str';\nimport { STRINGS } from './autotimezone_strings';\n\n\nvar STRING = null;\n/**\n * Automatic Time Zone Switcher.\n * @param {string} currentTimeZone The user's current timezone identifier.\n */\nexport const init = async (\n    currentTimeZone\n) => {\n    const RESULT_MATCH = \"match\";\n\n    Log.info(\"Loading autotimezone\");\n    const stringValues = await getStrings(\n        STRINGS.map(\n            (key) => ({key, component: 'local_autotimezone'}))\n    );\n    STRING = new Map(STRINGS.map((key, index) => ([key, stringValues[index]])));\n    Log.debug(STRING);\n\n    Log.info(currentTimeZone);\n    // We need access to the geolocation API.\n    if (!navigator.geolocation) {\n        Log.warn(\"No geolocation API available\");\n        return;\n    } else {\n        Log.info(\"Geolocation API available\");\n    }\n\n    // If the user's current location is not within the current time zone, we will switch it.\n    let watchid = navigator.geolocation.watchPosition(\n        (pos) => {\n            Log.info(\"Got position: \"+ pos.coords.latitude + \", \"+ pos.coords.longitude);\n            // Determine if current pos.coords is within the current time zone using api.timezonedb.com\n            checkTimezone(pos.coords.latitude, pos.coords.longitude)\n            .then((data) => {\n                Log.info(data);\n                if (data.status != RESULT_MATCH) {\n                    Log.warn(\"No match\");\n                    Log.info(\"Current time zone: \"+ data.profiletimezone);\n                    Log.warn(\"New time zone \"+ data.timezone);\n                    // Display some sort UI to the user to indicate that they're real\n                    // location doesn't match their time zone.\n                    // We really want this to be *non*-interruptive, but noticeable.\n                    updateIgnore(\n                        data.profiletimezone,\n                        data.timezone,\n                        () => {\n                            Log.info(\"Updating time zone to \" + data.timezone);\n                            updateTimeZone(data.timezone).then(() => {\n                                window.location.reload();\n                            });\n\n                        },\n\n                        () => {\n                            // Set user preference to not trigger checking for at least 24 hrs.\n                            const oneDay = 24 *60 * 60 * 1000;\n                            const now = new Date();\n                            const nextCheck = new Date();\n                            nextCheck.setTime(now.getTime() + oneDay);\n                            Log.info(\"Stopping location changes for 24 hrs \" + nextCheck.toISOString());\n                            deferChecks(nextCheck.getTime()/1000);// Convert to unixtimestamp in seconds.\n                        }\n                    );\n                }\n                navigator.geolocation.clearWatch(watchid);\n            })\n            .fail((error) => {\n                Log.error(error);\n                navigator.geolocation.clearWatch(watchid);\n            });\n        },\n        (error) => {\n            Log.error(error);\n            if (error.code == 2) {\n                Log.error(\"Unable to establish position\");\n            }\n            navigator.geolocation.clearWatch(watchid);\n        });\n};\n\nexport const updateIgnore = async (profileTz, currentTz, updateCallback, cancelCallback) => {\n    var pendingPromise = new Pending('local/autotimezone:updateIgnore');\n\n    const [\n        ModalEvents\n    ] = await Promise.all([\n        import('core/modal_events')\n    ]);\n\n    const title = STRING.get('updatemodaltitle');\n    const body = await getString(\n        'updatemodalbody', 'local_autotimezone',\n        {profileTz: profileTz, currentTz: currentTz}\n    );\n    const updateto = await getString(\n        'updatetimezoneto', 'local_autotimezone',\n        {currentTz: currentTz}\n    );\n    const modal = await UpdateIgnoreModal.create({\n        title,\n        body: body,\n        buttons: {\n            save: updateto,\n            cancel: STRING.get('ignorefor24hrs')\n        },\n        removeOnClose : true,\n        show:true\n    });\n    modal.getRoot().on(ModalEvents.save, updateCallback);\n    modal.getRoot().on(ModalEvents.cancel, cancelCallback);\n    pendingPromise.resolve();\n    return modal;\n};\n"],"names":["STRING","async","info","stringValues","STRINGS","map","key","component","Map","index","debug","currentTimeZone","navigator","geolocation","warn","watchid","watchPosition","pos","coords","latitude","longitude","then","data","status","profiletimezone","timezone","updateIgnore","window","location","reload","now","Date","nextCheck","setTime","getTime","toISOString","clearWatch","fail","error","code","profileTz","currentTz","updateCallback","cancelCallback","pendingPromise","Pending","ModalEvents","Promise","all","title","get","body","updateto","modal","UpdateIgnoreModal","create","buttons","save","cancel","removeOnClose","show","getRoot","on","resolve"],"mappings":"itBAwBIA,OAAS,mBAKOC,MAAAA,+BAKZC,KAAK,8BACHC,mBAAqB,mBACvBC,8BAAQC,KACHC,OAAUA,IAAAA,IAAKC,UAAW,6BAEnCP,OAAS,IAAIQ,IAAIJ,8BAAQC,KAAI,CAACC,IAAKG,QAAW,CAACH,IAAKH,aAAaM,wBAC7DC,MAAMV,qBAENE,KAAKS,kBAEJC,UAAUC,qCACPC,KAAK,6CAGLZ,KAAK,iCAITa,QAAUH,UAAUC,YAAYG,eAC/BC,mBACOf,KAAK,iBAAkBe,IAAIC,OAAOC,SAAW,KAAMF,IAAIC,OAAOE,yCAEpDH,IAAIC,OAAOC,SAAUF,IAAIC,OAAOE,WAC7CC,MAAMC,oBACCpB,KAAKoB,MA1BA,SA2BLA,KAAKC,sBACDT,KAAK,yBACLZ,KAAK,sBAAuBoB,KAAKE,8BACjCV,KAAK,iBAAkBQ,KAAKG,UAIhCC,aACIJ,KAAKE,gBACLF,KAAKG,UACL,kBACQvB,KAAK,yBAA2BoB,KAAKG,yCAC1BH,KAAKG,UAAUJ,MAAK,KAC/BM,OAAOC,SAASC,eAKxB,WAGUC,IAAM,IAAIC,KACVC,UAAY,IAAID,KACtBC,UAAUC,QAAQH,IAAII,UAHP,oBAIXhC,KAAK,wCAA0C8B,UAAUG,2CACjDH,UAAUE,UAAU,SAI5CtB,UAAUC,YAAYuB,WAAWrB,YAEpCsB,MAAMC,qBACCA,MAAMA,OACV1B,UAAUC,YAAYuB,WAAWrB,eAGxCuB,qBACOA,MAAMA,OACQ,GAAdA,MAAMC,mBACFD,MAAM,gCAEd1B,UAAUC,YAAYuB,WAAWrB,mBAIhCW,aAAezB,MAAOuC,UAAWC,UAAWC,eAAgBC,sBACjEC,eAAiB,IAAIC,iBAAQ,yCAG7BC,mBACMC,QAAQC,IAAI,umBAIhBC,MAAQjD,OAAOkD,IAAI,oBACnBC,WAAa,kBACf,kBAAmB,qBACnB,CAACX,UAAWA,UAAWC,UAAWA,YAEhCW,eAAiB,kBACnB,mBAAoB,qBACpB,CAACX,UAAWA,YAEVY,YAAcC,6BAAkBC,OAAO,CACzCN,MAAAA,MACAE,KAAMA,KACNK,QAAS,CACLC,KAAML,SACNM,OAAQ1D,OAAOkD,IAAI,mBAEvBS,eAAgB,EAChBC,MAAK,WAETP,MAAMQ,UAAUC,GAAGhB,YAAYW,KAAMf,gBACrCW,MAAMQ,UAAUC,GAAGhB,YAAYY,OAAQf,gBACvCC,eAAemB,UACRV"}